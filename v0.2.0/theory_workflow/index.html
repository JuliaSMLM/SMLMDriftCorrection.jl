<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Theory &amp; Workflow · SMLMDriftCorrection.jl</title><meta name="title" content="Theory &amp; Workflow · SMLMDriftCorrection.jl"/><meta property="og:title" content="Theory &amp; Workflow · SMLMDriftCorrection.jl"/><meta property="twitter:title" content="Theory &amp; Workflow · SMLMDriftCorrection.jl"/><meta name="description" content="Documentation for SMLMDriftCorrection.jl."/><meta property="og:description" content="Documentation for SMLMDriftCorrection.jl."/><meta property="twitter:description" content="Documentation for SMLMDriftCorrection.jl."/><meta property="og:url" content="https://JuliaSMLM.github.io/SMLMDriftCorrection.jl/theory_workflow/"/><meta property="twitter:url" content="https://JuliaSMLM.github.io/SMLMDriftCorrection.jl/theory_workflow/"/><link rel="canonical" href="https://JuliaSMLM.github.io/SMLMDriftCorrection.jl/theory_workflow/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SMLMDriftCorrection.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../configuration/">Configuration</a></li><li class="is-active"><a class="tocitem" href>Theory &amp; Workflow</a><ul class="internal"><li><a class="tocitem" href="#Background"><span>Background</span></a></li><li><a class="tocitem" href="#Drift-Model"><span>Drift Model</span></a></li><li><a class="tocitem" href="#Dataset-Modes"><span>Dataset Modes</span></a></li><li><a class="tocitem" href="#Quality-Tiers"><span>Quality Tiers</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Theory &amp; Workflow</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Theory &amp; Workflow</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaSMLM/SMLMDriftCorrection.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaSMLM/SMLMDriftCorrection.jl/blob/main/docs/src/theory_workflow.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Theory-and-Workflow"><a class="docs-heading-anchor" href="#Theory-and-Workflow">Theory and Workflow</a><a id="Theory-and-Workflow-1"></a><a class="docs-heading-anchor-permalink" href="#Theory-and-Workflow" title="Permalink"></a></h1><h2 id="Background"><a class="docs-heading-anchor" href="#Background">Background</a><a id="Background-1"></a><a class="docs-heading-anchor-permalink" href="#Background" title="Permalink"></a></h2><p>Sample drift is a fundamental challenge in single molecule localization microscopy (SMLM). During acquisition, thermal fluctuations, mechanical settling, and other perturbations cause the sample to move relative to the optical system. Because super-resolution images are constructed from thousands of individual localizations accumulated over minutes to hours, even nanometer-scale drift degrades the final resolution.</p><p>This package implements a <strong>fiducial-free</strong> drift correction algorithm – no reference markers are needed. Instead, the algorithm exploits the statistical redundancy inherent in SMLM data: the same fluorophores blink multiple times across different frames, creating repeated observations of fixed structures. By finding the drift trajectory that produces the tightest spatial clustering of these repeated observations, the drift can be estimated and corrected.</p><h2 id="Drift-Model"><a class="docs-heading-anchor" href="#Drift-Model">Drift Model</a><a id="Drift-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Drift-Model" title="Permalink"></a></h2><h3 id="Algorithmic-Framework"><a class="docs-heading-anchor" href="#Algorithmic-Framework">Algorithmic Framework</a><a id="Algorithmic-Framework-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithmic-Framework" title="Permalink"></a></h3><p>This package is based on <a href="https://doi.org/10.1038/s41598-021-02850-7">Wester et al. (2021)</a>, which introduced a two-phase parametric approach to fiducial-free drift correction:</p><ol><li><p><strong>Intra-dataset correction</strong>: Drift within each acquisition segment is modeled as a polynomial function of frame number (a proxy for time), with no constant term since global offsets are handled separately.</p></li><li><p><strong>Inter-dataset correction</strong>: Constant lateral shifts between datasets account for registration errors or repositioning between acquisition segments.</p></li></ol><p>This decomposition separates two physically distinct drift sources: continuous thermal/mechanical drift during acquisition (intra) and discrete repositioning errors between acquisitions (inter).</p><p>The current implementation makes two key updates to the original Wester et al. algorithm:</p><h3 id="Update-1:-Entropy-Cost-Function"><a class="docs-heading-anchor" href="#Update-1:-Entropy-Cost-Function">Update 1: Entropy Cost Function</a><a id="Update-1:-Entropy-Cost-Function-1"></a><a class="docs-heading-anchor-permalink" href="#Update-1:-Entropy-Cost-Function" title="Permalink"></a></h3><p>Wester et al. used a <strong>saturated nearest-neighbor distance</strong> cost function:</p><p class="math-container">\[C(\theta) = \sum_{i=1}^{N} \min(d_i, \ell)\]</p><p>where <span>$d_i$</span> is the nearest-neighbor distance for localization <span>$i$</span> after drift correction and <span>$\ell$</span> is a saturation threshold. The saturation prevents distant pairs (from different emitters) from dominating the cost. While effective, this cost function does not account for the varying localization precisions (<span>$\sigma$</span>) of individual localizations.</p><p>We adopted the <strong>entropy minimization</strong> cost function of <a href="https://doi.org/10.1364/OE.426620">Cnossen et al. (2021)</a>, which models the SMLM reconstruction as a Gaussian mixture:</p><p class="math-container">\[p(\mathbf{r}) = \frac{1}{N} \sum_{i=1}^{N} \mathcal{N}(\mathbf{r};\, \boldsymbol{\mu}_i - \mathbf{d}(t_i),\, \boldsymbol{\Sigma}_i)\]</p><p>where <span>$\boldsymbol{\mu}_i$</span> is the measured position, <span>$\boldsymbol{\Sigma}_i$</span> is the diagonal covariance from localization uncertainty, and <span>$\mathbf{d}(t_i)$</span> is the drift at frame <span>$t_i$</span>.</p><p>Since the entropy of a Gaussian mixture has no closed form, we minimize a <strong>variational upper bound</strong>:</p><p class="math-container">\[H_{\text{ub}}(\mathbf{D}) = \frac{1}{N}\sum_i H_i - \frac{1}{N}\sum_i \log\!\Bigl(\frac{1}{N}\sum_{j \neq i} e^{-D_{\text{KL}}(p_i \| p_j)}\Bigr)\]</p><p>The first term <span>$H_i$</span> is the entropy of each individual Gaussian component (determined only by localization uncertainties, constant during optimization). The second term depends on pairwise KL divergences between Gaussian localizations:</p><p class="math-container">\[D_{\text{KL}}(i, j) = \frac{1}{2}\sum_{k=1}^{K} \left[\log\frac{\sigma_{j,k}^2}{\sigma_{i,k}^2} + \frac{\sigma_{i,k}^2}{\sigma_{j,k}^2} + \frac{(\mu_{i,k} - \mu_{j,k})^2}{\sigma_{j,k}^2} - 1\right]\]</p><p>The drift parameters enter through the corrected positions <span>$\mu_{i,k}$</span>. When drift is correctly removed, localizations from the same emitter cluster tightly, the KL divergences shrink, and the entropy decreases.</p><p>For computational efficiency, the pairwise sum is truncated to the <strong>k nearest neighbors</strong> of each localization (default <span>$k = 200$</span>), computed via KDTree. The KDTree is rebuilt adaptively – only when the drift estimate changes by more than 100 nm – avoiding <span>$O(N \log N)$</span> rebuilds on every optimizer iteration.</p><h3 id="Update-2:-Legendre-Polynomial-Basis"><a class="docs-heading-anchor" href="#Update-2:-Legendre-Polynomial-Basis">Update 2: Legendre Polynomial Basis</a><a id="Update-2:-Legendre-Polynomial-Basis-1"></a><a class="docs-heading-anchor-permalink" href="#Update-2:-Legendre-Polynomial-Basis" title="Permalink"></a></h3><p>Wester et al. used standard monomials (<span>$f, f^2, \ldots$</span>) for the drift polynomial. We use <strong>Legendre polynomials</strong> (<span>$P_1(t), P_2(t), \ldots$</span>) evaluated on normalized time <span>$t \in [-1, 1]$</span>:</p><p class="math-container">\[t = \frac{2(f - 1)}{n_{\text{frames}} - 1} - 1\]</p><p>The orthogonality of the Legendre basis provides better optimization conditioning, especially for higher polynomial degrees. Each coefficient captures independent variation, preventing the numerical ill-conditioning that arises with standard polynomial bases at high degree.</p><p>As in Wester et al., the constant term (<span>$P_0$</span>) is excluded from the intra-dataset model. Global offsets are handled by the inter-dataset shifts.</p><h2 id="Dataset-Modes"><a class="docs-heading-anchor" href="#Dataset-Modes">Dataset Modes</a><a id="Dataset-Modes-1"></a><a class="docs-heading-anchor-permalink" href="#Dataset-Modes" title="Permalink"></a></h2><p>The package supports three acquisition scenarios through the <code>dataset_mode</code> parameter and chunking options:</p><h3 id="Continuous-(Single-Polynomial)"><a class="docs-heading-anchor" href="#Continuous-(Single-Polynomial)">Continuous (Single Polynomial)</a><a id="Continuous-(Single-Polynomial)-1"></a><a class="docs-heading-anchor-permalink" href="#Continuous-(Single-Polynomial)" title="Permalink"></a></h3><p>For short acquisitions (fewer than ~4000 frames), drift is modeled as a single polynomial over the entire dataset:</p><pre><code class="language-julia hljs">config = DriftConfig(dataset_mode=:continuous, degree=3)
(smld_corrected, info) = driftcorrect(smld, config)</code></pre><p>This fits one <span>$n$</span>-th order Legendre polynomial per spatial dimension to capture the smooth, continuous drift trajectory. Best when the drift is well-described by a low-order polynomial over the full acquisition.</p><h3 id="Continuous-(Piecewise-Chunked)"><a class="docs-heading-anchor" href="#Continuous-(Piecewise-Chunked)">Continuous (Piecewise Chunked)</a><a id="Continuous-(Piecewise-Chunked)-1"></a><a class="docs-heading-anchor-permalink" href="#Continuous-(Piecewise-Chunked)" title="Permalink"></a></h3><p>For long acquisitions, a single polynomial may not capture complex drift patterns or may become numerically unstable at high degree. The data is arbitrarily split into temporal chunks, each fit with its own polynomial:</p><pre><code class="language-julia hljs">config = DriftConfig(dataset_mode=:continuous, chunk_frames=4000)
(smld_corrected, info) = driftcorrect(smld, config)</code></pre><p>Each chunk is treated as a separate &quot;dataset&quot; internally. <strong>Warm-starting</strong> ensures continuity: each chunk&#39;s polynomial is initialized from the endpoint of the previous chunk&#39;s fit. The inter-dataset shifts chain the chunks together, with regularization from boundary gap estimates to prevent discontinuities. This piecewise approach provides the flexibility of high-order modeling without requiring a single high-degree polynomial over the full acquisition.</p><h3 id="Registered"><a class="docs-heading-anchor" href="#Registered">Registered</a><a id="Registered-1"></a><a class="docs-heading-anchor-permalink" href="#Registered" title="Permalink"></a></h3><p>For instruments that periodically register the sample to a reference position between acquisition segments – such as the Sequential Super-resolution Microscope (SeqSRM) described in <a href="https://doi.org/10.1364/BOE.477501">Schodt et al. (2023)</a> – the datasets are independent acquisitions with bounded drift:</p><pre><code class="language-julia hljs">config = DriftConfig(dataset_mode=:registered)
(smld_corrected, info) = driftcorrect(smld, config)</code></pre><p>Between acquisition segments, the microscope acquires a brightfield z-stack, computes 3D cross-correlation against a reference, and iteratively moves the stage to realign the sample. This bounds the inter-dataset drift to the registration precision (typically 5-10 nm lateral). However, residual registration errors and intra-segment drift still require computational correction.</p><p>In registered mode, datasets are spatially overlapping images of the same field of view. The inter-dataset alignment uses <strong>merged-cloud entropy</strong>: the shifted dataset&#39;s localizations are combined with reference dataset localizations into a single point cloud, and the entropy of the combined cloud is minimized. This finds the constant shift that produces the tightest merged distribution.</p><h2 id="Quality-Tiers"><a class="docs-heading-anchor" href="#Quality-Tiers">Quality Tiers</a><a id="Quality-Tiers-1"></a><a class="docs-heading-anchor-permalink" href="#Quality-Tiers" title="Permalink"></a></h2><p>The package provides three quality tiers that trade speed for accuracy. All three share the same drift model (Legendre polynomials + inter-shifts); they differ in how the model parameters are estimated.</p><div class="admonition is-success" id="Multi-threading-d2939da7e26cb8bc"><header class="admonition-header">Multi-threading<a class="admonition-anchor" href="#Multi-threading-d2939da7e26cb8bc" title="Permalink"></a></header><div class="admonition-body"><p>Intra-dataset correction is parallelized with <code>Threads.@threads</code> (each dataset is independent). The first inter-dataset pass (all vs dataset 1) is also threaded using a precomputed snapshot of corrected coordinates. Start Julia with multiple threads for best performance:</p><pre><code class="nohighlight hljs">julia -t auto        # use all available cores
julia -t 8           # use 8 threads</code></pre></div></div><h3 id="FFT-(:fft)"><a class="docs-heading-anchor" href="#FFT-(:fft)">FFT (<code>:fft</code>)</a><a id="FFT-(:fft)-1"></a><a class="docs-heading-anchor-permalink" href="#FFT-(:fft)" title="Permalink"></a></h3><p>The fastest tier. Uses <strong>cross-correlation</strong> of histogram images to estimate inter-dataset shifts. No intra-dataset polynomial fitting is performed.</p><p><strong>Procedure:</strong></p><ol><li>Build 2D (or 3D) histogram images from each dataset&#39;s localizations</li><li><strong>Pass 1</strong>: Compute cross-correlation of each dataset against dataset 1 via FFT; extract shift from the correlation peak with sub-pixel Gaussian refinement</li><li><strong>Pass 2</strong>: Refine each dataset&#39;s shift against a merged histogram of all other (shifted) datasets</li><li><strong>Pass 3</strong>: Detect outlier shifts (&gt;5 MAD from median) and re-align them using a Gaussian-damped cross-correlation prior</li></ol><p>Best for: quick previews, very large datasets, or as initialization for entropy-based methods.</p><h3 id="Singlepass-(:singlepass)"><a class="docs-heading-anchor" href="#Singlepass-(:singlepass)">Singlepass (<code>:singlepass</code>)</a><a id="Singlepass-(:singlepass)-1"></a><a class="docs-heading-anchor-permalink" href="#Singlepass-(:singlepass)" title="Permalink"></a></h3><p>The default tier. Performs one pass of entropy-based intra-dataset correction followed by inter-dataset alignment.</p><p><strong>Procedure:</strong></p><ol><li><strong>Intra-dataset correction</strong> (threaded across datasets):<ul><li>Initialize polynomial coefficients with small random values</li><li>Minimize entropy upper bound using Nelder-Mead optimization (10,000 iteration limit)</li><li>Adaptive KDTree rebuilding avoids unnecessary recomputation</li></ul></li><li><strong>Inter-dataset alignment, Pass 1</strong> (threaded, all vs dataset 1):<ul><li>For each dataset <span>$n &gt; 1$</span>, apply intra-correction to dataset <span>$n$</span> and full correction to dataset 1</li><li>Use cross-correlation for initial shift estimate</li><li>Refine via BFGS optimization of merged-cloud entropy</li></ul></li><li><strong>Inter-dataset alignment, Pass 2</strong> (sequential, each vs all earlier):<ul><li>For each dataset <span>$n$</span>, re-optimize the shift against all datasets <span>$1, \ldots, n-1$</span></li><li>This incorporates information from the intermediate datasets</li></ul></li><li>Apply corrections to produce the final SMLD</li></ol><p>For continuous mode, inter-shifts are warm-started from polynomial endpoint chaining and regularized using boundary gap estimates.</p><h3 id="Iterative-(:iterative)"><a class="docs-heading-anchor" href="#Iterative-(:iterative)">Iterative (<code>:iterative</code>)</a><a id="Iterative-(:iterative)-1"></a><a class="docs-heading-anchor-permalink" href="#Iterative-(:iterative)" title="Permalink"></a></h3><p>The most accurate tier. Iterates between intra and inter correction until convergence.</p><p><strong>Procedure:</strong></p><ol><li>Run the full singlepass procedure as initialization</li><li><strong>Iterate until convergence</strong> (default: max 10 iterations, tolerance 1 nm): a. Re-run intra-dataset correction with inter-shifts applied (shifted coordinates), threaded across datasets b. Re-run inter-dataset alignment using Jacobi-style updates (snapshot corrected data, then thread all-vs-others) c. Check convergence: maximum change in any inter-shift component &lt; <code>convergence_tol</code></li><li>Track entropy history for diagnostics (<code>info.history</code>)</li></ol><p>The iteration resolves the coupling between intra and inter corrections: the optimal polynomial depends on the inter-shifts, and vice versa. For data with significant inter-dataset drift, iterative mode can improve accuracy substantially over singlepass.</p><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><ul><li><p>Cnossen J, Cui TJ, Joo C, Smith C. &quot;Drift correction in localization microscopy using entropy minimization.&quot; <em>Optics Express</em> 29(18):27961-27974, 2021. <a href="https://doi.org/10.1364/OE.426620">DOI: 10.1364/OE.426620</a></p></li><li><p>Wester MJ, Schodt DJ, Mazloom-Farsibaf H, Fazel M, Pallikkuth S, Lidke KA. &quot;Robust, fiducial-free drift correction for super-resolution imaging.&quot; <em>Scientific Reports</em> 11:23672, 2021. <a href="https://doi.org/10.1038/s41598-021-02850-7">DOI: 10.1038/s41598-021-02850-7</a></p></li><li><p>Schodt DJ, Farzam F, Liu S, Lidke KA. &quot;Automated multi-target super-resolution microscopy with trust regions.&quot; <em>Biomedical Optics Express</em> 14(1):429-440, 2023. <a href="https://doi.org/10.1364/BOE.477501">DOI: 10.1364/BOE.477501</a></p></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../configuration/">« Configuration</a><a class="docs-footer-nextpage" href="../api/">API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Sunday 15 February 2026 16:35">Sunday 15 February 2026</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
